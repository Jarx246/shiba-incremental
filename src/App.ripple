import { useAtom } from 'jotai-ripple';
import { atomWithStorage, RESET } from 'jotai/vanilla/utils';
import Decimal from 'break_eternity.js';
import { track, effect } from 'ripple';
import * as EternalNotations from 'eternal_notations';

// const brah = new EternalNotations.ScientificNotation().format(1e100);

const INITIAL_DOG_LIMIT: Decimal = new Decimal(4);
const PRESTIGE_THRESHOLD = Decimal.pow(10, -100);

const limitAtom = atomWithStorage<Decimal>('shiba_limit', INITIAL_DOG_LIMIT, {
	getItem: (key: string): Decimal => {
		const raw = localStorage.getItem(key);
		return raw === null ? INITIAL_DOG_LIMIT : new Decimal(raw);
	},
	setItem: (key: string, value: Decimal): void => localStorage.setItem(key, value),
	removeItem: (key: string): void => localStorage.removeItem(key),
});

const remainderAtom = atomWithStorage<Decimal>('shiba_remainder', INITIAL_DOG_LIMIT, {
	getItem: (key: string): Decimal => {
		const raw = localStorage.getItem(key);
		return raw === null ? INITIAL_DOG_LIMIT : new Decimal(raw);
	},
	setItem: (key: string, value: Decimal): void => localStorage.setItem(key, value),
	removeItem: (key: string): void => localStorage.removeItem(key),
});

export component App() {
	const [remainder, setRemainder] = useAtom(remainderAtom);
	const [currentLimit, setCurrentLimit] = useAtom(limitAtom);

	const goUp = (): void => setRemainder(
		(r: Decimal) => @currentLimit.mul(r).div(@currentLimit.add(r)),
	);
	const prestige = (): void => {
		const newLimit = @currentLimit.add(1);
		setCurrentLimit(newLimit);
		setRemainder(newLimit);
	};

	let clickCount: Tracked<Decimal> = track(new Decimal(0));
	effect(() => (@clickCount = @currentLimit.div(@remainder).sub(1).round()));

	let visualValue: Tracked<Decimal> = track(new Decimal(0));
	effect(() => (@visualValue = @currentLimit.sub(@remainder))); // there was some bullshit happening here earlier i swear i saw it with my own two eyes. it made me do @visualValue = @dogLimit.sub(@remainder).plus(@currentLimit).sub(4)

	let canPrestige: Tracked<boolean> = track(false);
	effect(() => (@canPrestige = @remainder.lt(PRESTIGE_THRESHOLD)));

	<main>
		<section>
			if (@visualValue.lte(0)) {
				<h1>{'Shiba number (shumber): 1'}</h1> // this is kinda fucked up but shibas dont know how to count under 1 either so
			} else if (@visualValue.eq(@currentLimit)) {
				// <h1>{'Shiba number (shumber): not tellin yuo >:('}</h1> // ill probably try to make it fade out before this point lol
				<h1>
					{`Shiba number (shumber): ${@currentLimit} - ${EternalNotations.Presets.Default.format(
						@remainder,
					)}`}
				</h1>
				// } else if (@clickCount.lte(10) && @currentLimit.eq(4)) {
				// <h1>{`Shiba number (shumber): ${@visualValue}`}</h1> // do something funny here
			} else {
				<h1>{`Shiba number (shumber): ${@visualValue}`}</h1>
			}
			<h2>{`Times Clicked: ${EternalNotations.Presets.Default.format(@clickCount)}`}</h2>
			<button onClick={goUp}>{'go up!'}</button>
			if (@canPrestige) {
				<button onClick={prestige}>{`Shiba will count to ${@currentLimit}...`}</button>
			}
		</section>
		<Shop {currentLimit} {goUp} />
		<Debug />
	</main>

	<style>
		@font-face {
			font-family: 'ComicMono';
			src: url('/ComicMono.ttf') format('truetype');
			font-weight: normal;
			font-style: normal;
		}
		:global {
			h1 {
				white-space: nowrap;
			}
			main {
				display: flex;
				justify-content: flex-start;
				align-items: flex-start;
				height: 100vh;
				font-family:
					'ComicMono',
					'Comic Sans MS',
					Comic Sans,
					cursive;
				flex-direction: column;
			}
			button {
				margin: 0.5rem;
				padding: 0.5rem 1rem;
				cursor: pointer;
				font-family:
					'ComicMono',
					'Comic Sans MS',
					Comic Sans,
					cursive;
			}
		}
	</style>
}

const shibasAtom = atomWithStorage<string[]>('shiba_items', ['#FFA500']);

export component Shop(props: { currentLimit: Tracked; goUp: () => void }) {
	const [shibaClickers, setShibaClickers] = useAtom(shibasAtom);
	effect(() => {
		if (@shibaClickers.length <= 1) return;
		const id = setInterval(props.goUp, 1000 / (@shibaClickers.length - 1));
		return () => clearInterval(id);
	});

	const increaseShibas = () => {
		setShibaClickers([
			...@shibaClickers,
			function () {
				let r = Math.floor(Math.random() * 256);
				let g = Math.floor(Math.random() * 256);
				let b = Math.floor(Math.random() * 256);
				return `rgb(${r},${g},${b})`;
			}(),
		]);
	};
	<section>
		<h1>{'Shop'}</h1>
		<br />
		<button onClick={() => (increaseShibas())}>
			{'Hire a dog'}
			<br />
			{'to count for yuo!'}
		</button>

		<h3>{`dogs: ${@shibaClickers.length}`}</h3>

		<ul>
			for (const shibaColor of @shibaClickers) {
				<li style={{ color: shibaColor }}>{'â– '}</li>
			}
		</ul>
	</section>

	<style>
		ul {
			list-style: none;
			padding: 0;
			margin: 0;
			display: flex;
			flex-wrap: wrap;
		}

		li {
			/*
			padding: 8px 12px;
			border: 1px solid #ccc;
			border-radius: 4px;
			*/
		}
	</style>
}

export component Debug() {
	const [remainder, setRemainder] = useAtom(remainderAtom);
	const [currentLimit, setCurrentLimit] = useAtom(limitAtom);
	const [shibaClickers, setShibaClickers] = useAtom(shibasAtom);

	let debug: Tracked<boolean> = track(false);

	<section>
		<button onClick={() => (@debug = !@debug)}>
			<h1>{'debug menu'}</h1>
		</button>

		if (@debug) {
			<h3>{`Current Limit: ${@currentLimit}`}</h3>
			<h3>
				{`Internal distance to ${@currentLimit}: ${EternalNotations.Presets.Scientific.format(
					@remainder,
				)}`}
			</h3>
			<button onClick={(): void => setRemainder(PRESTIGE_THRESHOLD.div(10))}>
				{'Prestige Button (gold star for you!)'}
			</button>
			<button onClick={() => setRemainder(RESET)}>
				{'Reset Boy (poor lil guy)'}
				<br />
				{'he will have to start all over again'}
				<br />
				{'yuo moster!'}
			</button>
			<button onClick={() => setCurrentLimit(RESET)}>{'Reset Press-teach (enstupiden)'}</button>
			<button onClick={() => setShibaClickers(RESET)}>
				{'Reset Shibas (kill them. kill them all'}
			</button>
		}
	</section>
}
