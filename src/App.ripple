import { useAtom } from 'jotai-ripple';
import { RESET } from 'jotai/vanilla/utils';
import Decimal from 'break_eternity.js';
import { track, effect } from 'ripple';
import * as EternalNotations from 'eternal_notations';
import { limitAtom, remainderAtom, shibasAtom, lastSeenAtom } from './atoms.ts';

// const brah = new EternalNotations.ScientificNotation().format(1e100);

const PRESTIGE_THRESHOLD = Decimal.pow(10, -100);

export component App() {
	let hydrated: Tracked<boolean> = track(false);
	effect(() => {
		if (!@currentLimit.eq(4) || !@remainder.eq(4)) {
			@hydrated = true;
		}
	});

	const [remainder, setRemainder] = useAtom(remainderAtom);

	const [currentLimit, setCurrentLimit] = useAtom(limitAtom);
	const goUp = (): void => setRemainder(
		(r: Decimal) => @currentLimit.mul(r).div(@currentLimit.add(r)),
	);
	const prestige = (): void => {
		const newLimit = @currentLimit.add(1);
		setCurrentLimit(newLimit);
		setRemainder(newLimit);
	};

	const [shibaClickers, setShibaClickers] = useAtom(shibasAtom);
	const [lastSeen, setLastSeen] = useAtom(lastSeenAtom);

	let offlineApplied: Tracked<boolean> = track(false);
	effect(() => {
		if (!@hydrated) return;
		const now = Date.now();
		const prev = @lastSeen ?? now;

		// write immediately to prevent double-apply on refresh
		setLastSeen(now);

		const elapsedMs = now - prev;
		if (elapsedMs <= 0) return;

		const clickers = @shibaClickers.length ?? 0;
		if (clickers <= 0) return;

		const seconds = new Decimal(elapsedMs).div(1000);
		const deltaClicks = seconds.mul(clickers);

		const r0 = new Decimal(@remainder);
		if (r0.eq(0)) return;

		// s = 1 / r
		const s0 = new Decimal(1).div(r0);
		const s1 = s0.add(deltaClicks.div(@currentLimit));
		const r1 = new Decimal(1).div(s1);

		setRemainder(r1);
	});

	effect(() => {
		const saveNow = () => {
			try {
				setLastSeen(Date.now());
				console.log('Saved');
			} catch {
				console.log('fuck');
			}
		};

		const onVisibility = () => {
			if (document.visibilityState === 'hidden') saveNow();
		};
		const onBeforeUnload = () => saveNow();

		document.addEventListener('visibilitychange', onVisibility);
		window.addEventListener('beforeunload', onBeforeUnload);
		const id = setInterval(saveNow, 30000); // every 30s

		return () => {
			clearInterval(id);
			document.removeEventListener('visibilitychange', onVisibility);
			window.removeEventListener('beforeunload', onBeforeUnload);
		};
	});

	let clickCount: Tracked<Decimal> = track(new Decimal(0));
	effect(() => (@clickCount = @currentLimit.div(@remainder).sub(1).round()));

	let visualValue: Tracked<Decimal> = track(new Decimal(0));
	effect(() => (@visualValue = @currentLimit.sub(@remainder))); // there was some bullshit happening here earlier i swear i saw it with my own two eyes. it made me do @visualValue = @dogLimit.sub(@remainder).plus(@currentLimit).sub(4)

	let canPrestige: Tracked<boolean> = track(false);
	effect(() => (@canPrestige = @remainder.lt(PRESTIGE_THRESHOLD)));

	<main>
		<section>
			if (@visualValue.lte(0)) {
				<h1>{'Shiba number (shumber): 1'}</h1> // this is kinda fucked up but shibas dont know how to count under 1 either so
			} else if (@visualValue.eq(@currentLimit)) {
				// <h1>{'Shiba number (shumber): not tellin yuo >:('}</h1> // ill probably try to make it fade out before this point lol
				<h1>
					{`Shiba number (shumber): ${@currentLimit} - ${EternalNotations.Presets.Default.format(
						@remainder,
					)}`}
				</h1>
				// } else if (@clickCount.lte(10) && @currentLimit.eq(4)) {
				// <h1>{`Shiba number (shumber): ${@visualValue}`}</h1> // do something funny here
			} else {
				<h1>{`Shiba number (shumber): ${@visualValue}`}</h1>
			}
			<h2>{`Times Clicked: ${EternalNotations.Presets.Default.format(@clickCount)}`}</h2>
			<button onClick={goUp}>{'go up!'}</button>
			if (@canPrestige) {
				<button onClick={prestige}>{`Shiba will count to ${@currentLimit}...`}</button>
			}
		</section>
		<Shop {currentLimit} {goUp} />
		<Debug />
	</main>

	<style>
		@font-face {
			font-family: 'ComicMono';
			src: url('/ComicMono.ttf') format('truetype');
			font-weight: normal;
			font-style: normal;
		}
		:global {
			h1 {
				white-space: nowrap;
			}
			main {
				display: flex;
				justify-content: flex-start;
				align-items: flex-start;
				height: 100vh;
				font-family:
					'ComicMono',
					'Comic Sans MS',
					Comic Sans,
					cursive;
				flex-direction: column;
			}
			button {
				margin: 0.5rem;
				padding: 0.5rem 1rem;
				cursor: pointer;
				font-family:
					'ComicMono',
					'Comic Sans MS',
					Comic Sans,
					cursive;
			}
		}
	</style>
}

export component Shop(props: { currentLimit: Tracked; goUp: () => void }) {
	const [shibaClickers, setShibaClickers] = useAtom(shibasAtom);
	effect(() => {
		if (@shibaClickers.length <= 1) return;
		const id = setInterval(props.goUp, 1000 / (@shibaClickers.length - 1));
		return () => clearInterval(id);
	});

	const increaseShibas = () => {
		setShibaClickers([
			...@shibaClickers,
			function () {
				let r = Math.floor(Math.random() * 256);
				let g = Math.floor(Math.random() * 256);
				let b = Math.floor(Math.random() * 256);
				return `rgb(${r},${g},${b})`;
			}(),
		]);
	};
	<section>
		<h1>{'Shop'}</h1>
		<br />
		<button onClick={() => (increaseShibas())}>
			{'Hire a dog'}
			<br />
			{'to count for yuo!'}
		</button>

		<h3>{`dogs: ${@shibaClickers.length}`}</h3>

		<ul>
			for (const shibaColor of @shibaClickers) {
				<li style={{ color: shibaColor }}>{'â– '}</li>
			}
		</ul>
	</section>

	<style>
		ul {
			list-style: none;
			padding: 0;
			margin: 0;
			display: flex;
			flex-wrap: wrap;
		}

		li {
			/*
			padding: 8px 12px;
			border: 1px solid #ccc;
			border-radius: 4px;
			*/
		}
	</style>
}

export component Debug() {
	const [remainder, setRemainder] = useAtom(remainderAtom);
	const [currentLimit, setCurrentLimit] = useAtom(limitAtom);
	const [shibaClickers, setShibaClickers] = useAtom(shibasAtom);

	let debug: Tracked<boolean> = track(false);

	<section>
		<button onClick={() => (@debug = !@debug)}>
			<h1>{'debug menu'}</h1>
		</button>

		if (@debug) {
			<h3>{`Current Limit: ${@currentLimit}`}</h3>
			<h3>
				{`Internal distance to ${@currentLimit}: ${EternalNotations.Presets.Scientific.format(
					@remainder,
				)}`}
			</h3>
			<button onClick={(): void => setRemainder(PRESTIGE_THRESHOLD.div(10))}>
				{'Prestige Button (gold star for you!)'}
			</button>
			<button onClick={() => setRemainder(RESET)}>
				{'Reset Boy (poor lil guy)'}
				<br />
				{'he will have to start all over again'}
				<br />
				{'yuo moster!'}
			</button>
			<button onClick={() => setCurrentLimit(RESET)}>{'Reset Press-teach (enstupiden)'}</button>
			<button onClick={() => setShibaClickers(RESET)}>
				{'Reset Shibas (kill them. kill them all'}
			</button>
		}
	</section>
}
